# frozen_string_literal: true

require 'octokit'
require_relative '../lib/github_repository'

BRANCH_NAME_PREFIX = 'version-toolkit'
SUBMODULE_REPOSITORY_NAME = 'wordpress/gutenberg'
SUBMODULE_PATH = 'gutenberg'
CLIENT_REPOSITORY_NAME = 'oguzkocer/version-test-bin'
#FILTER_LABEL = 'Mobile App - i.e. Android or iOS'
FILTER_LABEL = '[Block] Table'

def client_branch_name_for_submodule_pr(submodule_pr)
  "#{BRANCH_NAME_PREFIX}/#{SUBMODULE_PATH}/#{submodule_pr.head.ref}"
end

def new_pull_request_body(submodule_path, submodule_pr_url)
  return %Q(
## Related PRs

* #{submodule_pr_url}

## Description

This PR is generated by `version-toolkit` to downstream the changes for #{submodule_path} submodule.
  )
end

client = Octokit::Client.new(access_token: ENV['VERSION_TOOLKIT_GITHUB_TOKEN'])
client.auto_paginate = true
submodule_repo = GithubRepository.new(client, SUBMODULE_REPOSITORY_NAME)
client_repo = GithubRepository.new(client, CLIENT_REPOSITORY_NAME)

# Find which submodule PRs should be downstreamed
puts "Fetching #{SUBMODULE_REPOSITORY_NAME} pull requests ..."
submodule_prs_to_downstream = submodule_repo.open_pull_requests().filter do |pr|
  !pr.fork && pr.labels.any? do |label|
    label.name == FILTER_LABEL
  end
end.to_h { |pr| [client_branch_name_for_submodule_pr(pr), pr] }
puts "Found #{submodule_prs_to_downstream.length} #{SUBMODULE_REPOSITORY_NAME} pull requests to automate"

# Find client PRs that are automated by us
puts "Fetching #{CLIENT_REPOSITORY_NAME} pull requests ..."
client_downstreamed_prs = client_repo.open_pull_requests().filter do |pr|
  pr.head.ref.start_with?(BRANCH_NAME_PREFIX)
end.to_h { |pr| [pr.head.ref, pr] }
puts "Found #{client_downstreamed_prs.length} pull requests automated by us"

# Find client PRs that no longer has an associated submodule PR and close them
# puts "Closing pull requests that no longer has an associated submodule pull request ..."
# TODO: Close these pull requests unless there are any other changes to it
# candidate_client_pull_requests_to_close = client_downstreamed_prs.filter do |branch_name, _|
#   submodule_prs_to_downstream.key?(branch_name)
# end

# Create a branch for submodule PRs that don't already have an associated client PR
puts "Creating new branches ..."
(submodule_prs_to_downstream.keys - client_downstreamed_prs.keys).each do |branch_name|
  client_repo.create_branch_from_default_branch(branch_name)
end

# For every submodule PR, create a submodule hash update commit with the hash from the corresponding submodule PR if necessary
puts "Creating commits for each submodule PR ..."
submodule_prs_to_downstream.each do |client_branch_name, submodule_pr|
  submodule_pr_commit_hash = submodule_pr.head.sha
  if client_repo.submodule_commit_hash(client_branch_name, SUBMODULE_PATH) != submodule_pr_commit_hash
    client_repo.create_submodule_hash_update_commit(client_branch_name,
                                             SUBMODULE_PATH,
                                             submodule_pr_commit_hash,
                                             "Update #{SUBMODULE_PATH} submodule hash to #{submodule_pr_commit_hash}")
  end
end

# For every submodule PR, if there is no associated client PR, open one
puts "Opening pull requests ..."
submodule_prs_to_downstream.filter do |branch_name, _|
  !client_downstreamed_prs.key?(branch_name)
end.each do |branch_name, submodule_pr|
  client_repo.create_pull_request(branch_name, submodule_pr.title, new_pull_request_body(SUBMODULE_PATH, submodule_pr.html_url))
end
